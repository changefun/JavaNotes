## 常量（constant）
<br>

### A. 字面常量
- 字符串常量（双引号括起来的内容）
- 字符常量（单引号括起来的单个字符、数字或符号，空格也算，不能为空）
- 整型常量（自然数例如12345等等）
- 浮点型常量（带有小数点的数字）
- 布尔常量（true真和false假）
- 空常量（null）

```java
class ConstantTest{
    public static void main(String[] args){
        System.out.println("abcd");// 字符串常量
        System.out.println('a');// 字符常量
        System.out.println(1234);//整型常量
        System.out.println(1.2);//浮点型常量
        System.out.println(true);// 布尔常量
        System.out.println(null);//空常量
    }
}
```
<br>

## 进制（scale）
### A. 理解

        1个开关有开和关两种状态表示0，1。计算机规定8个开关（0/1）为基本单位，称8bit（位）。
    
- 1byte（字节） = 8 bit（位）
- 1kbyte（千字节） = 1024 byte（字节）
- 1mbyte（兆字节） = 1024 kbyte
- 1gbyte（千兆字节） = 1024 mbyte
### B. 各种进制
- 二进制：0和1，逢二进一：1+1=10（二进制）=2（十进制）
- 八进制：0~7，逢八进一：1+7=10（八进制）=8（十进制）
- 十进制：0~9，逢十进一：1+9=10（十进制）
- 十六进制：0~9A~F，逢十六进一：1+F=10（十六进制）=16（十进制）
```java
class ScaleTest{
    public static void main(String[] args){
        /* java7之后 */
        System.out.println(0b10); // 前面加0b，二进制写法，输出2
        System.out.println(010); // 前面加0，八进制写法，输出8
        System.out.println(10);// 普通十进制
        System.out,println(0x10); //前面加0x，十六进制写法，输出16
    }
}
```
### C. 进制转换
1.  __X 进制转换为十进制__
- 系数：每位数（e.g. 123中的1、2、3）
- 基数：X进制，X为基数
- 权：从右数开始数，0开始编号（e.g 12345,权为4）
- 结果：SUM（系数 * 基数^权）

        二进制转十进制
        0b10010 = (1 * 2^4) + (0 * 2^3) + (0 * 2^2) + (1 * 2^1) + (0 * 2^0) = 18
        八进制转十进制
        01212 = (1 * 8^3) + (2 * 8^2) + (1 * 8^1) + (2 * 8^0) = 512+128+8 = 648
        十六进制转十进制
        0x2b = (2 * 16^1) + (11 * 16^0) = 43
2. __十进制转换为 X 进制__
- 公式： 十进制数值除以 X 进制直至商为0，再从下到上取其余数

    ![进制转换](./_C_2.png)

3. __任意进制转换为任意进制__
> 8421 快速转换法：第3、2、1、0位对应的8、4、2和1

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| - | - | - | - | - | - | - | :-|
| 1*2^7 | 1*2^6 | 1*2^5 | 1*2^4 | 1*2^3 | 1*2^2 | 1*1^7 | 1*0^7 |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
||||||||
- 十进制快速转换为二进制：
    - 123比第7位的128小故取0
    - 123比第6位的64大故取1，且123-64=59
    - 59比第5位的32大故取1，且59-32=27
    - 27比第4位的16大故取1，且27-16=11
    - 11比第3位的8大故取1，且11-8=3
    - 3比第2位的4小故取0
    - 3比第1位的2大故取1，且3-2=1
    - 1和第0位的1相等故取1，且1-1=0
    - __结果：123 = 01111011__
- 二进制快速转换为八进制：
    - 1111011每3位为1单位：1、111和011
    - 第一个单位1对照表第0位的状态也是1，故取其值1
    - 第二单位111分别对应表的第0、1和2位，因其状态都为1，故取其值4+2+1=7
    - 第三单位的011分别对应表的第0、1和2位，因011的第2位为0，故不取表对应的第2位的值，所以剩下的1+2=3
    - __结果： 173__
- 二进制快速转换为十六进制：
    - 1111011每4位为1单位：111和1011
    - 第一单位1111对应表中的第0、1和2位，因为都为1，故取其值4+2+1=7
    - 第二单位1011同上，但有0的存在，所以对应表中相应第2位的值不取，剩下的8+2+1=11，即B
    - __结果： 0x7B__
- 十进制要想快速转换为其他进制，就要先转换为二进制。
#### D. 机器正负运算（原码、反码和补码）
- 原码：最高位存放正负，正为0，负为1
    - e.g. 1的正二进制为0001，负二进制为1001；同样3的正二进制为0011，负二进制为1011.
    - 方便人类快速识别二进制正负，但阻碍了计算机运算。
    - e.g. （+1）+（-1）应等0，但计算机算出0001+1001=1010。如果按照原码的方式看则为-2.明显不对。
    - __另一个问题是存在（+0）和（-0）两个0__
- 反码：专门用于处理负数，符号位置不变，其余位取反
    - e.g. 原码中负数1010（-2）转换为反码1101（-2）
    - 原码转换为反码，可以解决“正负相加等于0”
    - __但还剩下（+0）和（-0）的问题__
- 补码：在原来反码的基础上，补充或加上一个新的码（+1）
    - e.g. 反码中的负数1111（-0）加上（+1）转换为补码0000（0），1110（反码-1）转为1111（补码-1），其他依次类推。
    - 当反码1111（-0）补1之后，变成10000，丢掉最高位就是0000，干好是正数的0。
    - __正负数相加等于0的问题同样满足__
    - e.g. 3和（-3）相加，0011 + 1101 = 10000，去掉最高位，就是0000，全面解决问题！

    ![原反补码](./scale_D.png)
- 正负运算：
    - 1减去3
    - = 1+(-3)
    - = 0001 + 1011 (原码)   
    - = 0001 + 1100 (反码)   
    - = 0001 + 1101 (补码)   
    - = 1110 (补码)，将其再转回原码：          
    - = 1101 (反码)          
    - = 1010 (原码，最高位1为负，010为2，故为-2)
- 已知补码，求原码：
    - __如果该补码的符号为正，则其原码就是这个补码__
    - __如果该补码的符号为负，则对该补码再次求补码就是要求的原码。__
- 负数的补码：
    - 对负数的绝对值二进制全部取反(包括符号位)再加1,则为该负数的补码
    - e.g. -35的补码
    - -35的的绝对值35的二进制为00100011
    - 全部取反为11011100
    - 再加1为11011101,这就是-35的补码
- A减去B = A加(-B)的补码（A、B>0）
- 反正运算时都得将参与运算的数转换为补码运算，最后结果转回原码，取正负和尾数就是答案。
<br>

## 数据类型
> Java设定具体的数据类型一个重要原因是可以更好地利用内存资源。
### A. 数据类型分类
__1. 基本数据类型（4类8种）__
- 整形
    - __byte：占一个字节(8bit)   （-128到127）__
    - short：占两个字节 （-2^15 ~ 2^15 - 1）
    - int：占四个字节 （-2^31 ~ 2^31 - 1）
    - long：占八个字节 （-2^63 ~ 2^63 - 1)
- 浮点型
    - float：占四个字节 （-3.403E38 ~ 3.403E38）单精度
    - double：占八个字节 （-1.798E308 ~ 1.798E308） 双精度
- 字符型
    - char：占两个字节  （0 ~ 65535）只有正的
- __布尔型__
    - __boolean：理论上占八分之一个字节(1bit位),但Java没有明确指定布尔型的空间大小。__

__2. 引用数据类型__
> - 数组
> - 类
> - 接口
> - 枚举

__3. 数据类型转换_隐式转换__
> 当空间大的数据类型和较之空间小的数据类型进行运算时，会先将空间小的数据类型转换为空间大的数据类型再进行运算。
```java
class DataTypeConversionTest{
    public static void main(String args[]){
        int a = 3;
        byte b = 5;
        byte c = a + b;
        System.out.println(c);
        // 发生编译错误：不兼容的类型: 从int转换到byte可能会有损失
    }
}
```
![数据隐式转换](./datatype_A_3.png)

__4. 数据类型转换_强制转换(高级向低级转换)__

> 高级类型数据和低级类型数据运算结果为高级类型，如果将结果赋给低级类型声明的值，则需要在前面加(低级类型)来将高级类型数据强制转换为低级类型数据。
```java
class DataTypeConversionForce{
    /*强制转换*/
    DataTypeConversionForce(){
        int i = 3;
        byte b = 4;
        // 前面加上 (byte) 强制转换为byte类型
        byte result = (byte)(i + b);
        System.out.println(result);//输出7,因为7在-128到127之间，所以编译器允许赋值给byte类型。

        int i2 = 128;
        byte b2 = 10;
        byte result2 = (byte)(i2 + b2);
        // 输出是-118,因为i2+b2=138,已经超出byte的取值范围-128～127了，损失精度(砍掉前面三个字节)。

        byte b3 = (byte)300;
        //输出44
    }
}
```


> 上面例子，强制转换会将int类型(占4个byte)的result去掉前面的3个byte，只留下一个byte，就转变成byte类型了(占1个byte)。这样的话，如果result的值超过byte类型的空间大小(-128～127),即超过一字节，就会损失精度。

> 例如result2的结果竟是-118,这是因为机器运算得出的结果是10001010(138),这是-118的补码，将其补码转回原码就是-118了。

> b3的输出竟然是44,300的二进制是100101100，9位，因为int转byte会砍掉前面3个字节，所以最后只剩下 00101100，因为最高位为0即正数，所以求它的原码就是它的补码，00101100转为十进制为44.

<font color="red" size="4">__面试题_变量相加和常量相加对于类型转换的区别:__</font>
```java
void DataTypeConversionForce_2(){
        /*数据类型强制转换中的变量相加和常量相加*/
        byte b1 = 3;
        byte b2 = 4;
        /*报错，1、因为3和4是int类型，运算结果也是int。将int数据赋值给byte类型会损失精度
        * 2、 b1和b2是两个变量，变量储存的值是变化得，编译时无法判断里面具体得值，相加可能会超出byte范围*/
        byte b3 = b1 + b2;

        /*常量相加*/
        byte b4 = 3 + 4;
        /*不报错，因为java编译器有常量优化机制
        * 编译时，已知常量3和4,且不再改变，运算得出的结果如果判断超过byte
        * 范围，且未进行强制转换，则报错
        * 否则赋值*/
    }
```

__5. 不同数据类型的变量定义__

```java
class DataTypeDefineTest{
    public static void main(String[] args){
        /* 加上后缀只是告诉JVM这是什么类型的值，并没有强制转换的发生 */
        /* 整型 */
        byte b = 1; // 占一个字节 -128~127
        short s = 12; // 占两个字节  -2*10^15~2*10^15-1
        int i = 123; //所有整数值默认为int
        long l = 12344L; //因为所有整数值默认为int，最好加L后缀告诉JVM这是long，防止出错。不加也不影响，因为JVM会自动转换为long，前提是不超过取值范围

        /* 浮点型 */
        float f = 1.33F; //因为所有浮点型数值默认为double型，不加F标识的话以为着将double类型的值赋给float，报错
        double d = 2.333; //浮点型数值默认类型

        /* 字符型 */
        char c = 'c';

        /* 布尔型 */
        boolean tf = true;//或者false
    }
}
```
__6. 字符和字符串参与运算__
- 字符(char)类型数据与int类型数据相加，会先将字符根据ASCII码表转换为int类型数字，再和int类型数据运算。
    ```java
    char c = 'c'; // 'c'字符在ASCII码表中是99
    int i = 1;

    System.out.println(c+i);// 输出100，99+1=100
    System.out.println((char)(c+i));// 输出'd'字符，100对应
    System.out.println('a'+'c');//输出196,char一旦参与数学运算都将转换为int

    ```
    ```java
    char c1 = 97;
    char c2 = 98;
    System.out.println(c1);//输出a
    System.out.println(c2);//输出b
    /*为什么输出ab? 因为char的取值范围是0～65535, 97和98不超出
    * 范围，所以编译器将其当作ASCII码处理*/
    ```
    > java中的char可以储存一个中文字符么？为什么？

        可以，因为java采用Unicode编码。Unicode编码中的每个字符占2个字节，中文单个汉字也占2个字节，所以char可以储存一个中文汉字.

- 任何类型数据用 + 与字符串相连接都会产生新的字符串。按照运算优先级产生的内容也不相同。
    ```java
    /*任何类型数据用 + 和字符串连接(强调连接而不是运算)都产生新的字符串*/
    System.out.println("hello"+2); // 输出 hello2
    System.out.println("hello" + 'c'); //输出 helloc
    System.out.println("hello"+true); // 输出 hellotrue
    System.out.println(2 + 'c' + "hello");// 输出 101hello
    System.out.println("hello" + 2 + 'c');// 输出 hello2c
    System.out.println("5 + 5 = " + 5+5);// 输出 5 + 5 = 55
    System.out.println("5 + 5 = " + (5+5));// 输出 5 + 5 = 10,优先级
    ```
    > 注：因为是强调“连接”，而不是运算，所以字符char不会转换为int，这就是为啥输出helloc。

    > 一般按照从左到右执行，没有加括号的话。

<br>

## 运算符(operator)
> 对常量和变量进行操作的符号。
- 算术运算符：+、-、*、/、%、++、--
- 赋值运算符：=、+=、-=
- 比较(关系/条件)运算符：>、<、>=、<=、!=
- 逻辑运算符：&&、||
- 位运算符：
- 三目(元)运算符
> 注意：+号三种作用，正、加法、字符串连接符
### A.算术运算符
__1. %(模，取余)：__
```java
void Demo(){
    /* % 模运算符，取余*/
    /* % 运算结果的正负根据左边值正负*/

    /*当左边值的绝对值小于右边绝对值时，结果为左边*/
    System.out.println(-3 % 5);//输出 -3
    System.out.println(-3 % -5);//输出 -3
    System.out.println(-12 % 5);//输出 -2

    /*当左边的绝对值等于右边或右边的倍数时，结果是0*/
    System.out.println(-9 % 3);// 输出 0
    System.out.println(-9 % -3);// 输出 0
    System.out.println(-3 % -3);// 输出 0

    /*当左边绝对值大于右边绝对值时，结果为余数*/
    System.out.println(-4 % 3);// 输出 -1
    System.out.println(4 % 3);// 输出 1
    System.out.println(4 % -3);// 输出 1
    
    /*奇数 %2 为1,偶数 %2 为0，,可用作切换条件*/
    System.out.println(4 % 2);// 输出 0
    System.out.println(5 % 2);// 输出 1
    System.out.println(6 % 2);// 输出 0
}
```
__2.　++a先自增,a++后自增(减):__
> 在未参与运算(或赋值)时，一般a++和++a的效果是一样的
```java
int i = 1;
i++; // 输出２

int j = 2;
++j; // 输出３
```
> 但一旦参与运算或赋值，a++就会先将ａ赋给目标，然后才自增；而++a则先自增后再赋给目标。
```java
int a = 1;
int b = a++; // 输出ｂ为１，ａ为２

int c = 1;
int d = ++c; // 输出ｄ为２，ｃ为２

int x = 1;
int y = (x++)+(++x)+(x*10);
/*　开始ｘ参与运算，先将x初始值取出(1)，然后自增，此时ｘ已经变成2。然后到第二步(++x),这里先自增x变成了3。第三步x*10则为30。所以最终结果为 1+3+3×10=34 */
```
<font color="red">__面试题_下面那一句会报错：__</font>
```java
byte b = 10;
b++;// 这等价于 b = (byte)(b + 1) JVM自动强制转换，所以这句不报错.
b = b + 1;// JVM会先将b(byte)变量提升为int然后再参与运算，结果为int，无法赋值给byte类型，需要手动强制转换
```

### B. 逻辑运算符
__1.异或(^)__
> 真假异或

    符号左右两边同为true或false时，则结果为false。
    否则两边分别是true和false时，则结果为true。
    总结：两者同则false，异则true
> 异或运算
```java
4 ^ 6:
= 100 ^ 110 (二进制)
= 010 (同则0,异则1)
= 2 (十进制)
```
__2.与(&/&&)、或(|/||):__
> 与&：两者同时成立则true，否则false

> 与&&：<font color="green">和&相同效果，但有短路功能=>A&&B，如果A判定为false，则不需要再判断B了，因为这足可以判定整个条件不成立了。</font>

> 或|：两者之一成立则true，否则false

> 或 ||：<font color="yellow">同上，A||B,如果A为true，则不需判断B了，因为已经有一个成立了，足以判断条件是否成立了。</font>
    
    短路功能可以节省计算资源。

### C.位运算符
> 位与运算：
```java
4 & 6：
= 100 & 110
= 100 (同1则1，否则0)和逻辑与一样
= 4
```
> 位或运算：
```java
例子：
4 | 6：
= 100 | 110
= 110 (有1则1,否则0)
= 6

// 简单模式
4 | -7：
= 100 | 001(-7的补码)
= 101 (结果也是补码，要转为原码)
= 110 (尾数取反，符号位不变)
= 111
= -3 (原码)
等价于：
// 具体模式
= 00000000 00000000 00000000 00000100 | 11111111 11111111 11111111 11111001
= 11111111 11111111 11111111 11111101
= 10000000 00000000 00000000 00000010
= 10000000 00000000 00000000 00000011
= -3
```
> 位取反运算：
```java
～4：
= 00000000 00000000 00000000 00000100
= 11111111 11111111 11111111 11111011 (取反运算:全体取反)，//这里是补码，需要转换为原码来看
= 10000000 00000000 00000000 00000100 (尾数位取反)
= 10000000 00000000 00000000 00000101 (补码)
= -5 (原码)
// 为什么这么多01,因为4是int类型，所以最高位是第31位即符号位
```
<font color="red">__面试题_实现两个变量的交换__</font>
```java
/* 异或运算的特点：
*  一个数A对另一个数B异或运算两次，还是这个数A,变回自己 */
// 推荐方案
int a = 10;
int b = 3;
a = a ^ b; // 10 ^ 3
b = a ^ b; // 10 ^ 3 ^ 3 = 10
a = a ^ b; // 10 ^ 3 ^ 10 = 3
// a = 3, b = 10 交换成功

// 另一个方案
a = a + b; // 10+3=13
b = a - b; // 13-3=10
a = a - b; // 13-10=3
// a=3, b=10 交换成功，但是缺陷是如果a和b运算结果超出int取值范围，就会报错

// 又一个方案
int temp = a; // temp=10
a = b; // a=3
b = temp; // b=10
// 开发推荐，但面试可能会限制这个中间条件
```
### D.位运算符（<<、>>）
__1.左移<<__

        二进制位向左移 N 位，等价于该数乘2的 N 次方，左边移出去N位，右边补N个0。
```java
12 << 1:
00000000 00000000 00000000 00001100 = 
00000000 00000000 00000000 00011000 = 24
    
```
__2.右移>>和无符号右移>>>__

        右移 N 位，等价于该数除以2的 N 次方，左边最高位若是1则补1,否则补0.
```java
12 >> 3:
00000000 00000000 00000000 00001100 = 
00000000 00000000 00000000 00000001 = 1

2147483656 >>> 1:无符号右移
10000000 00000000 00000000 00001000 = 
01000000 00000000 00000000 00000100 = 1073741828
```

<br>

## 键盘输入
- 导包：`import java.util.Scanner;`
- 创建扫描对象：`Scanner sc = new Scanner(System.in);`
- 通过该对象获取数据：`int x = sc.nextInt();//整型获取`

<br>

## 流程控制结构
- 顺序结构： 普通从上到下依次执行
- 选择结构： 也叫分支结构，if/else和switch语句
- 循环结构： for、while、do/while和foreach语句

### A.选择结构(分支结构)
#### 1. if/else语句：
- 格式1：
    ```java
    int age = 19;
    if (age >= 18){
        // 语句
    }
    ```
- 格式2：
    ```java
    // 不加大括号，则只控制离它最近的一句话，是一句话！！！
    if (age < 11)
        int a = 13; // 报错，因为该语句共两句，int a和a = 13
    ```
- 格式3：
    ```java
    if (条件1){
        //xx
    }else if(条件2){
        // xxx
    }else{
        //最后一个else可以忽略
    }
    ```
#### 2. switch语句：
- 格式：
    ```java
        switch(表达式){
            case 值:
                // 语句
                break;
            case 值2:
                // 语句
                break;
            default:
                // 语句
                break;
        }
    ```
    > - 表达式可以接受的基本数据类型：
    byte、short、char、int
    > - 可以接受String类型、枚举。<br>

    > 注意事项：
    > - case后面只能常量
    > - 多个case后面的值不能重复
    > - 如果不加break，匹配完当前值后会继续向下穿透匹配，直至遇到break关键字或代码结束}。

<br>

### B. 循环结构
> 在循环体内可以通过 break 关键字停止整个循环;通过continue关键字可以直接执行下次循环。
#### 1. for循环
```java
for(初始化表达式; 循环条件; 循环后的操作表达式){
    // 循环体
}
```
- __流程：__
    - __a__ 初始化表达式执行（首次）
    - __b__ 判断循环条件
    - __b__ true则执行循环体,false退出循环
    - __c__ 执行完循环体执行循环后的操作表达式
    - 第二次循环从 b 步骤开始

`for(;;){} // 无限循环`

#### 2. while循环
```java
while(i < 100(判断条件语句)){
    循环体;
    i++/i--等(控制条件语句);
}
```
#### 3. do/while循环    
> 特别的是无论如何都会执行一次循环体，不管判断成不成立。较之for和while执行0次以上的循环体，do/while是执行1次以上循环体。
```java
do {
    循环体语句;
    控制条件语句;
}while(判断条件语句);
```
 - 流程
    - a.首先不管三七二十一先执行循环体
    - b.控制条件语句变化条件
    - c.判断条件
    - true继续从a执行

__三种循环结构的区别：__<br>
        
    for循环：初始化的迭代变量循环完被释放，不再可用，而且外部无法调用迭代变量(局部变量)。
#### 4. 标号控制
合法的标号名加上冒号(apple:)
> 一般用于嵌套循环，控制外循环跳出(break)、跳过(continue)。
```java
static void ControlCycle(){
    /*标号控制一般用于控制外循环*/
    outer: for (int i = 0; i < 3; i++){
        System.out.println("外循环"+i);
        inner: for (int j = 0; j < 2; j++){
            System.out.println("内循环"+j);
            continue outer;
            // 或break outer;
        }
    }
}
```
<font color="red">__标号的陷阱__</font>
```java
System.out.println("第一句");
http://www.baidu.com
System.out.println("第二句");
输出：
    第一句
    第二句
/* "http:" 是个合法标号。而后面的网址是注释(坑)，两条斜杆。
* 标号控制的是第二句*/
```
<br>

## 方法
### 方法重载
> 方法名相同，参数不同，与返回值类型无关
- 参数个数不同
- 参数类型不同

<br>

## 数组
> 引用数据类型
### 1.数组初始化
- 动态初始化(元素不确定)<br>
    > 数据类型[] 数组名 = new 数据类型[数组长度]
    ```java
    int[] apple = new int[3];
    /* int[] 一维数组
    *  int[][] 二维数组 */
    ```
    > 数组初始化会有默认值
    ```java
    整型：byte、short、int和long默认初始化值是0
    浮点型：float和double是0.0
    布尔：默认false
    字符：char默认值是'\u0000',
          char在内存中占两个字节，16个二进制位，
          \u0000,每个0是16进制的0,而一个16进制位用4个二进制位表示，转换为二进制\u0000 0000 0000 0000,16个0.
    ```
    > “new int[3]” 返回数组的信息：[I@7f31245a
    ```java
    [I@7f31245a
    [： 一维数组
    I:  int类型、byte则是B、short则是S、boolean则是Z等等
    @：固定格式
    7f31245a：内存地址值
    ```
- 静态初始化(元素确定)
    > 数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...}
    ```java
    int[] apple = new int[]{1,2,3};
    ```

    简化格式
    > 数据类型[] 数组名 = {元素1,元素2,...}
    ```java
    int[] apple = {1,2,3};
    ```

    两种格式的区别：
    > 标准格式可以先定义：int[] apple;后赋值：apple = new int[]{1,2,3};<br>
    而简化格式则会出错。


### 3.堆栈
- 堆：存储new出来的数组或对象
- 栈：存储局部变量(定义在方法声明上和方法内的变量)，先进后出（先进的压箱底）
- 方法区：面向对象占位
- 本地方法区
- 寄存器：cpu使用
![堆栈](./数组/数组_堆栈.png)

### 4.数组的操作
- 获取数组的长度
    ```java
    int[] apple = {1,2,3};
    int array_length = apple.length;
    ```
### 5.二维数组
#### 格式
- 数据类型[][] 数组名 = new 数据类型[m][n];
- 数据类型[] 数组名[] = new 数据类型[m][n];
- 数据类型[][] 数组名 = new 数组类型[m][];
    - 数组名[0] = new 数据类型[3];
    - 数组名[1] = new 数据类型[4];
    - .......
- 数据类型[][] 数组名 = {{1,2},{3,4,5},{6}};(静态)

#### 注意：
```java
int[] x,y[]; // x为一维数组，y为二维数组
x = new int[]{1,2,3};
y = new int[][]{2,3,4};
```
#### 二维数组的内存表现形式
> 二维数组创建时，第一维数组用于存储第二维数组的内存地址。
```java
int[][] apple = new int[3][2];
apple // [[I@1b2c3d 第一维数组的内存信息
apple[0] // [I@4c2a22 第一维数组的0索引位置存储的是另一个数组的内存信息。
```

### 6.数组作为参数在方法中的传递
> &nbsp;&nbsp;&nbsp;&nbsp;由于数组是引用数据类型，所以数组作为参数传递给方法时，实际上是将数组的内存地址传给方法。在方法内对数组进行的一切操作都会改变原数组，因为方法是根据传进来的原数组的内存地址来对原数组进行操作。
```java
static void changeArray(int[] arr){
    arr[0] = 1;
}

public static void main(String[] agrs){
    int[] a = {2};
    changeArray(a); // 传递的是a数组的内存地址
    System.out.println(a[0]); //输出 1
}
```

## 面向对象
### 程序执行时在JVM内存中如何表现的？
- __a__ 编译器将源代码编译成.class文件，即字节码文件,有多少个类就编译成多少个.class文件。
- __b__  首先是主类.class文件通过类加载器载入到内存的方法区(JVM)。
- __c__  方法区内，在静态区发现main主方法时，将main()压进栈内存区。
- __d__  main()进栈，执行main()里的语句：
    ```java
    public static void main(String[] args){
        Student student1 = new Student();// 执行到这句时，先在栈内存申请一块空间，名字叫student1，用来存储new返回的地址值。
    }
    ```
- __e__ 执行到new Student()时，类加载器将Student.class文件载入JVM内存方法区中，static静态变量也进行了默认初始化：
    ```java
    Student student1 = new Student();// 从方法区中找到Student类信息，然后在堆内存中申请一块空间，并依照这些类信息实例化出实体，里面存储的是对象属性，然后进行初始化工作三部曲。
    ```
- __f__ 这里还有一步，如果有static关键字修饰的静态变量显式赋值的话，在第一次实例化对象时就显式初始化静态变量。由于对象实体是根据类信息（在方法区）来构建，所以可以找到静态变量的地址，从而对它赋值，完成显式初始化：
    ```java
    private static String school = "九小"; // 类的第一次实例化时，就对静态变量显式初始化，这时在方法区的静态区的静态变量从null变成“九小”。
    ```
- __g__ 默认初始化即null（String)、0（整型）、false（boolean）、0.0（浮点型）、\u0000（char).
- __h__ 显式初始化即赋值给对象属性：
    ```java
    class Student{
        // 创建对象时的显式初始化
        private String name = "张三";
    }
    ```
- __g__ 调用构造函数初始化时，构造函数进栈，完成工作后出栈。
    ```java
    class Student{
        private String name;

        public Student(String name){
            this.name = name; // 构造方法初始化
        }
    }
    ```
- __h__ 所有初始化完成后，返回地址给变量（局部的）Student s。
- __i__ 局部变量 s 指向的是对象的地址，通过地址可以直接操作在堆内存中的对象属性：s.name="张三";
- __j__ s调用study()时，study()从方法区中压进栈内存中。
- __k__ study()中隐藏着一个变量this，s调用study()方法时就将堆内存中的实体的地址赋予给this。study()方法就可以凭着地址去堆内存中找数据和操作数据。
- study()操作完后出栈。

[参考链接](https://www.cnblogs.com/wxw7blog/p/7349204.html)
### java的垃圾回收机制
> &nbsp;&nbsp;&nbsp;&nbsp;创建对象时，会在jvm的堆内存开辟一块空间储存对象的实体，并返回对象实体的内存地址。局部变量接收这个地址就可以调用这个对象。而一旦将null或者其他东西赋予给这个局部变量，就会覆盖掉前面记录的对象实体内存地址。这时位于堆内存中的对象实体没有任何变量指向或引用它，它就会成为垃圾，jvm的垃圾回收机制会在不定时回收这些垃圾。

> &nbsp;&nbsp;&nbsp;&nbsp;由于方法是在栈中工作的，执行完后就会弹栈，而在方法内定义的对象、变量等等都会消失。而方法内指向堆内存中的对象实体变成了垃圾，被jvm回收掉。

### 局部变量和成员变量
- 区别
    - 在类中的位置不同
        - 成员变量：在类之中方法之外
        - 局部变量：在方法中定义或声明
    - 在内存中的位置不同
        - 成员变量：在堆内存（属于对象范畴，对象进堆内存）
        - 局部变量：在栈内存（属于方法，方法进栈内存）
    - 生命周期不同
        - 成员变量：随着对象的创建而存在，消失而消亡
        - 局部变量：随着方法的调用而存在，调用完毕而消失。
    - 初始化值不同
        - 成员变量：有默认初始化值。
            ```java
            class A{
                public String name; // 定义未赋值
                public int age;
            }
            public class B{
                public static void main(String[] args){
                    A a = new A();
                    int test;
                    System.out.println(test); // 报错，未赋值
                    System.out.println(a.name); // 输出 null(String默认值)
                    System.out.println(a.age); // 输出 0(int默认值)
                }
            }
            // 各种类型的成员变量默认值
            // 整型的都是0
            // 浮点型的都是0.0
            // char是'\u0000'打印的是空格
            // 布尔的是false
            ```
        - 局部变量：没有默认初始化值，必须在使用前定义和赋值。
- 注意
    - 局部变量名和成员变量名可以一样，方法调用时采取就近原则

### 创建的对象作为参数传递给方法时
> &nbsp;&nbsp;&nbsp;&nbsp;对象作为参数传递给方法，实质是将对象在堆内存中的地址传给方法。(引用的传递)，这时方法内对传入的对象地址进行的操作都会改变堆中的对象。
```java
class A{
    public String name = "李四";
}

public class {

    public static void changeA(A a){
        a.name = "张三";
    }

    public static void main(String[] args){
        A a = new A();
        System.out.println(a); // 对象地址：A@7f31245a
        System.out.println(a.name); // 输出李四

        changeA(a);
        System.out.println(a); // 对象地址：A@7f31245a（对象地址不变，说明操作同一个对象）
        System.out.println(a.name); // 输出张三，对象a的属性name已经被改变
    }
}
```

### 匿名对象
> 没有名称的对象
- 匿名对象的应用场景
    - 匿名对象在调用方法时，仅仅调用一次。
        - 匿名对象只用完一次后就变成垃圾，被回收
        ```java
        new Student().study();
        // 因为new完没有将内存地址赋予给任何变量，所以一旦new完调用方法完毕后就变成垃圾了。
        ```
    - 匿名对象可以作为实际参数传递给方法
        ```java
        Teacher(new Student());
        ```
### 封装
> 隐藏对象的属性和实现细节，仅对外提供公共访问方式。
- 优点
    - 隐藏实现细节
    - 复用性高
    - 安全性高
### this关键字
> 对象本身的引用
    
        创建对象后，对象调用成员方法时，例如student.study(),study()方法有个隐藏的this，student对象调用的时候会将对象实体内存地址告诉study()中的this，study()方法就可以凭地址去找堆内存的对象实体进行操作。

> 用于区分成员方法的形参名和成员变量名。
```java
Student student = new Student();
student.setName("张三");

...

private String name;    // 成员变量

public void setName(String name){ // 形参（方法的局部变量）
    name = name; // 形参名和成员变量名相同了
    // 两者名称相同时会导致赋值成员变量失败，因为当成员变量和局部变量同名时，方法内部采取就近原则，先采用局部变量。所以上面的结果是 成员变量name还是null，并没有赋值。
    
}
```

### 构造方法
#### 格式
- 构造方法名必须和类名相同
- 一般为public修饰（提供给公共）
    - 可以是private（私有构造方法）
        - 如果类中所有方法都是静态方法，推荐私有化构造方法，这样就不能实例化对象了。
- 不可以写void，写void就不是构造方法
- 没有返回值，但可写“return;”可不写。

> 通过方法重载可以写多个参数列表不同的构造方法。
```java
Student student = new Student("张三",24);
Student student = new Student("李四",23, "女");

...

class Student{
    public Student(String name, int age){
        ...
    }

    public Student(String name, int age, String gender){
        ...
    }
}
```

> 如果不编写任何构造方法，系统会默认提供无参构造方法

> 一旦编写有参构造方法，系统便不提供默认构造方法，如果你在创建对象时不传入参数，就会报错，所以一般加上自己写的无参构造方法。
```java
class Student{
    public Student(String name){
        ...
    }
}

...

Student student = new Student();// 报错：实际参数列表和形式参数列表长度不同。
```
> __以上的问题可以解决，将形参设为[数据类型... 形参名]：__
```java
class Student{
    public Student(String... names){
        System.out.println(names[0]+names[1]);
    }
}

main(){
    Student student = new Student(); //不会报错
    Student student = new Student("张三","李四");//不会报错
}
/*
* “数据类型... 形参名” 这种形式可以接受0个或以上的参数，这样就不用定义构造方法时写多个无参构造方法，方法重载也方便。
*/
```

### 构造方法和setXXX()
#### 构造方法
- 在创建对象时对兑现熟悉初始化，初始化后的对象属性如果没有提供公共方法来修改，意味着初始化完就固定下来了。
#### setXXX方法
- 可以灵活的修改对象属性

### static关键字和静态变量
#### 静态变量在内存中的表现
- 类加载器加载.class文件（字节码）进JVM的方法区
    - 这时，类的静态变量进行默认初始化
- 实例化对象时，根据方法区的某个类的类信息，在堆内存中申请一块空间用来存储对象属性。
    - 这时，对类的静态变量进行显式初始化，即赋值。
- 实例化第二个对象，重复第二步。
    - 这时，已经不再对静态变量进行显式初始化了，因为已经被初始化过了，除非手动进行。这里也可以调用这个静态变量了。
- 实例化n个对象，都可以调用这个静态变量。

#### static关键字（静态变量）的特点
1. 随着类的加载而加载并默认初始化
2. __优先于对象存在__
    - 因为是先加载类，再到根据类信息实例化对象。
3. 被类的所有对象共享
    - 因为无论多少个对象都是根据方法区的类的信息实例化出来的，大家都可以访问静态区的静态变量
4. 可以通过类名来调用
    - 其实也可以通过对象调用
    - 推荐类名调用
    ```java
    class A{
        private static String name = "小明";
    }

    ...

    main(){
        A.name = "小红"; // 前面并没有实例化对象，这里却可以通过类名调用
    }
    ```

- 什么场景用静态变量？
    - 如果某个成员变量，无论多少个对象都一样的，则将该成员变量用static修饰变成静态变量。

- 注意事项
    - 静态成员方法无法访问非静态成员
        - 因为静态成员是随着类加载而加载，非静态成员则随着对象创建而存在，类加载优先于对象的创建，非静态成员可能都未存在就让静态方法给调用了，自然就无法调用啦。
    - 静态方法只能访问静态成员（成员变量和成员方法）。

- 静态变量和成员变量的区别
    - 所属不同
        - 静态变量属于类，亦称类变量
        - 成员变量属于对象，亦称实力变量
    - 内存中的位置不同
        - 静态变量存储在方法区的静态区
        - 成员变量则存储在堆内存
    - 在内存中出现的时间不同
        - 静态变量随着类的加载而存在，随着类的消失而消失
        - 成员变量随着对象的创建而存在，消失而消失
    - 调用方式不同
        - 静态变量可以通过类名来调用，也可以通过对象来调用
        - 成员变量只能通过对象来调用

### 主方法main()
```java
public class Main{
    public static void main(String[] args){
        //
    }
}
```
- public
    - 需要被JVM调用，所以权限必须要大
- static
    - JVM调用，应该直接通过类名来调用，不用再去实例化对象调用。
- void
    - JVM调用main()不需要任何返回值，因为返回值也不知道给谁用。
- main
    - 不是关键字,只是JVM识别的固定函数名

### 说明文档的生成
#### 步骤
- 在源代码首部位置添加注释：
    ```java
    /**
    这是该类的功能介绍
    @author [作者]xxx
    @version [代码版本]v1.0
    */
    ```
- 在每个方法前面添加注释：
    ```java
    /**
    这是该方法的功能说明
    @param [参数说明]arr [这里写参数说明]
    @return [返回值说明]xxx [这里写返回值说明]
    */
    ```
- 用javadoc命令生成说明文档
    ```shell
    $ javadoc -d [指定生成目录] -author -version [java源文件]
    ```
    > 需要注意的是，java文件中的类得是public修饰。
- 生成后，打开前面指定的目录，里面有个index.html,打开即可查看。

<br>

### 代码块
> 格式：
```java
{
    // 代码
}
```
#### 局部代码块
- 在方法内部使用，限定变量生命周期，及早释放，提高内存利用率：
    ```java
    public void test(){
        {
            int x = 520; // 大括号外面无法调用
        }
        System.out.println(x);// 找不到符号错误
    }
    ```
#### 构造代码块（初始化块）
- 在类之中在方法之外；如果多个构造方法中都有相同的代码，将这代码提取成构造代码块
    ```java
    class Student{
        {
            System.out.println("我在学习");
        }

        public Student(){
            System.out.println("我在学习"); // 这代码大家都有，作为构造代码块方便。
        }

        public Student(String name){
            System.out.println("我在学习"); // 这代码大家都有，作为构造代码块方便。
        }
    }
    ```
- __每次创建对象都会执行，而且比构造方法先执行。__

#### 静态代码块
- 在类之中在方法之外；以static修饰。首次实例化对象时，优先于构造方法执行，如果还有其它静态变量，则看谁在上谁先执行。并且只执行一次，无论创建多少次对象：
    ```java
    class Student{
        static{
            System.out.println("静态代码块只行一次，无论创建多少个对象");
        }

        public Student(){}
    }
    ```
- 一般用于加载驱动
#### 代码块的优先级
1. 静态代码块（只在首次创建对象时执行一次）
2. 静态变量常量（只在首次创建对象时执行一次）
3. 构造代码块
4. 构造方法

<br>

### 继承
- 继承的好处
    - 提高代码的复用性
    - 提高代码的维护性
    - 多态的前提
- 继承的弊端
    - 类的耦合性增强（父类发生改动，子类跟着改动）
        - 耦合：两者之间的关系
        - 内聚：个体可以自身单独完成功能

#### JAVA继承的特点
- 只支持单继承。（一个子类只能继承一个父类）
- 支持多层继承（形成继承体系）

#### JAVA继承注意事项
- 子类只能继承父类的非私有成员（非private修饰）
- 子类不能继承父类的构造方法，但可通过 super 关键字来访问。

#### 关于继承中的构造方法
- 子类在实例化对象时，无论调用该子类中的任何构造方法，都会先调用父类的无参构造方法。但如果父类已经存在有参构造方法（即意味着JVM将不提供默认无参构造方法），又不手动给父类提供无参构造方法，编译会出错：
    ```java
    class A{
        public A(){
            // 手动提供无参构造方法
            System.out.print("A的无参构造方法");
        }

        public A(String name){
            // 有参构造方法一旦存在，jvm就不会提供默认无参构造方法了
            System.out.println("A的有参构造方法");
        }
    }

    class B extends A{
        public B(){
            // 无论子类哪个构造方法，都会先隐藏调用父类的无参构造方法
            // super()
            System.out.println("B的无参构造方法");
        }

        public B(String name){
            // super(); 默认隐藏调用父类的无参构造方法
            System.out.println("B的有参构造方法");
        }
    }

    /* new B():
    输出结果：
        A的无参构造方法
        B的无参构造方法

    new B("haha"):
    输出结果：
        A的无参构造方法
        B的有参构造方法
    
    一旦注释掉A的无参构造方法，而A也存在有参构造方法，jvm不提供无参构造方法。这时就会编译不通过。
    */
    ```
    疑惑：默认无参构造方法是用来给成员变量默认赋值的，那如果类没有成员变脸呢?
    - 为什么都会访问到父类的默认无参构造方法？
        - 因为子类继承了父类的可继承数据，也可能会使用到继承下来的数据，所以要想使用父类的数据就要初始化这些数据。

#### 父类和子类的成员变量关系
- 如果父类和子类有相同的成员变量，则优先使用子类的成员变量。

#### this和super
- 调用成员（成员变量和成员方法）
    - this.成员
        - 调用本类的成员，也可以调用父类的成员（前提是本类没有和父类相同的成员）
    - super.成员
        - 调用父类的成员变量
- 调用构造方法
    - this(...) 调用本类的构造方法
    - super(...) 调用父类的构造方法

